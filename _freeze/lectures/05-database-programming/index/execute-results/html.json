{
  "hash": "3af3ce37a25d7e9e8555a4991a7c96a6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Database programming paradigms\"\nauthor: \n  - name: Stephanie Hicks\n    url: https://stephaniehicks.com\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Relational databases and SQL basics\"\ndate: 2025-11-11\ndraft: true\n---\n\n# Pre-lecture activities\n\n::: callout-important\n\nFor this lecture, we will use Unix shell, plus [SQLite3](https://www.sqlite.org/index.html) or [DB Browser for SQLite](https://sqlitebrowser.org).\n\nYou can see if the command-line tool `sqlite3` (also known as \"SQLite\") is already installed with \n\n\n::: {.cell}\n\n```{.bash .cell-code}\nsqlite3 --version\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3.43.2 2023-10-10 13:08:14 1b37c146ee9ebb7acd0160c0ab1fd11017a419fa8a3187386ed8cb32b709aapl (64-bit)\n```\n\n\n:::\n:::\n\n\nIf not, you can follow the instructions here: \n\n- <https://swcarpentry.github.io/sql-novice-survey>\n\nAlso, you will need to install these R packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"DBI\")\ninstall.packages(\"RSQLite\")\ninstall.packages(\"dbplyr\")\n```\n:::\n\n\n:::\n\nIn addition, please read through\n\n- [Relational databases and SQL basics](../../readings/05-database-programming/index.qmd)\n- <https://swcarpentry.github.io/sql-novice-survey> (Chapters 1-4)\n\n\n::: callout-note\n\n## How much should I prepare for before class? \n\nPlease install the packages above and be comfortable with running the functions in the example code here: \n\n- <https://dbi.r-dbi.org>\n- <https://solutions.posit.co/connections/db/databases/sqlite/>\n- <https://dbplyr.tidyverse.org>\n\n:::\n\n\n# Lecture \n\n## Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n- <https://swcarpentry.github.io/sql-novice-survey>\n\n\n## Learning objectives\n\n::: callout-note\n### Learning objectives\n\n**At the end of this lesson you will:**\n\n- Explain the difference between a table, a record, and a field in relational databases\n- Explain the difference between a database and a database manager\n- Write a query to select all values for specific fields from a single table\n- Write queries that display results in a particular order\n- Write queries that eliminate duplicate values from data\n- Write queries that select records that satisfy user-specified conditions\n- Learn about the `DBI`, `RSQLite`, `dbplyr` packages for making SQL queries in R\n\n:::\n\n\n\n## Slides \n\n- [Lecture 05: Database programming paradigms](https://docs.google.com/presentation/d/1KzExDgW77QqyPbPRKpnd0GNHZbzfl9IgtLKIyEW6Bp0/edit?usp=sharing)\n\n# Class activity \n\nFor the rest of the time in class, we will practice creating a SQL database and also writing SQL syntax to analyze a Beyoncé discography dataset. \n\n::: callout-note\n### Objectives of the activity\n\n- Practice creating a SQL database in R .\n- Practice filtering, grouping, and joining data using SQL commands.\n\n:::\n\nFor this in-class activity, you need to find a partner. Work together on the following problems. Use the following datasets related to Beyoncé's songs for the activity. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsongs <- data.frame(\n  song_id = 1:10,\n  title = c(\"Crazy in Love\", \"Halo\", \"Single Ladies\", \"Formation\", \"Irreplaceable\", \n            \"Drunk in Love\", \"Run the World\", \"Partition\", \"Love on Top\", \"Sorry\"),\n  album_id = c(1, 2, 1, 3, 2, 3, 1, 3, 2, 3),\n  release_year = c(2003, 2008, 2008, 2016, 2006, 2013, 2011, 2013, 2011, 2016),\n  streams_millions = c(500, 600, 700, 800, 900, 1000, 450, 350, 750, 900)\n)\n\n# Sample data frame for Beyoncé's albums\nalbums <- data.frame(\n  album_id = 1:3,\n  album_title = c(\"Dangerously in Love\", \"I Am... Sasha Fierce\", \"Lemonade\"),\n  release_year = c(2003, 2008, 2016)\n)\n```\n:::\n\n\n\n## Part 1: Create a SQL database\n\n- Create a new SQL database titled `beyonce.sqlite` using the `DBI` and `RSQLite` packages using the `dbConnect()` function. \n- Using the `dbWriteTable()` function, add the `songs` and `albums` datasets to the SQL database. \n\n::: {.callout-tip collapse=\"true\"}\n### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This code to ensure that the lecture builds and there no SQL database at the start of the exercise\nsql_beyonce <- here::here(\"data\", \"beyonce.sqlite\")\nif(file.exists(sql_beyonce)){\n  file.remove(sql_beyonce)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(DBI)\nmydb <- dbConnect(drv = RSQLite::SQLite(), \n                  dbname = sql_beyonce)\n\ndbWriteTable(conn = mydb, name = \"songs\", value = songs)\ndbWriteTable(conn = mydb, name = \"albums\", value = albums)\ndbListTables(conn = mydb)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"albums\" \"songs\" \n```\n\n\n:::\n:::\n\n\n:::\n\n## Part 2: Practice SQL queries \n\n- Write a SQL query that selects all columns from the songs table where the number of streams is greater than 600 million.\n\n::: {.callout-tip collapse=\"true\"}\n### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- dbGetQuery(mydb, \"SELECT * \n                             FROM songs\n                             WHERE streams_millions > 600;\")\nprint(results)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  song_id         title album_id release_year streams_millions\n1       3 Single Ladies        1         2008              700\n2       4     Formation        3         2016              800\n3       5 Irreplaceable        2         2006              900\n4       6 Drunk in Love        3         2013             1000\n5       9   Love on Top        2         2011              750\n6      10         Sorry        3         2016              900\n```\n\n\n:::\n:::\n\n\n:::\n\n- Use SQL to select the titles of Beyoncé’s songs released after 2010, along with the year they were released.\n\n::: {.callout-tip collapse=\"true\"}\n### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- dbGetQuery(mydb, \"SELECT title, release_year \n                             FROM songs \n                             WHERE release_year > 2010;\")\nprint(results)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          title release_year\n1     Formation         2016\n2 Drunk in Love         2013\n3 Run the World         2011\n4     Partition         2013\n5   Love on Top         2011\n6         Sorry         2016\n```\n\n\n:::\n:::\n\n\n:::\n\n\n- Write a SQL query that counts the number of songs for each album.\n\n::: {.callout-tip collapse=\"true\"}\n### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- dbGetQuery(mydb, \"SELECT album_id, COUNT(song_id) AS song_count\n                             FROM songs\n                             GROUP BY album_id;\")\nprint(results)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  album_id song_count\n1        1          3\n2        2          3\n3        3          4\n```\n\n\n:::\n:::\n\n\n:::\n\n- Write a SQL query that calculates the total streams for each album. Select the album ID, album title, and total streams.\n\n::: {.callout-tip collapse=\"true\"}\n### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- dbGetQuery(mydb, \"SELECT album_id, title, SUM(streams_millions) AS total_streams \n                             FROM songs \n                             GROUP BY album_id;\")\nprint(results)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  album_id         title total_streams\n1        1 Crazy in Love          1650\n2        2          Halo          2250\n3        3     Formation          3050\n```\n\n\n:::\n:::\n\n\n:::\n\n- Identify the least streamed song for each release year.\n\n::: {.callout-tip collapse=\"true\"}\n### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- dbGetQuery(mydb, \"SELECT release_year, title, MIN(streams_millions) AS min_streams\n                             FROM songs\n                             GROUP BY release_year;\")\nprint(results)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  release_year         title min_streams\n1         2003 Crazy in Love         500\n2         2006 Irreplaceable         900\n3         2008          Halo         600\n4         2011 Run the World         450\n5         2013     Partition         350\n6         2016     Formation         800\n```\n\n\n:::\n:::\n\n\n\n\nClose connection when done\n\n::: {.cell}\n\n```{.r .cell-code}\ndbDisconnect(conn = mydb)\n```\n:::\n\n\n:::\n\n## Part 3: Discussion\n\nDiscuss with your partner: \n\n- How does SQL make it easier to analyze and summarize data?\n- Which SQL query might you use to quickly identify Beyoncé’s most popular song based on streams?\n- How could these SQL skills be applied to other areas of data analysis?\n\n\n# Post-lecture\n\n## Additional practice\n\nHere are some additional practice questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\nUsing the `survey.db` database discussed in the [relational databases and SQL basics](../../readings/05-database-programming/index.qmd) pre-reading material: \n\n1. Use `.schema` to identify column that contains integers\n2. Write a query that selects only the `name` column from the `Site` table.\n3. Many people format queries in the following two ways. What style do you find easiest to read, and why?\n\n```\nSELECT personal, family FROM person;\n```\n\nor\n\n```\nselect Personal, Family from PERSON;\n```\n\n4. Write a query that selects distinct dates from the `Visited` table.\n5. Write a query that displays the full names of the scientists in the `Person` table, ordered by family name.\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}