{
  "hash": "471169971d16143db50ea25bbbf80fbc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Functional Programming with `purrr`\"\nauthor: \n  - name: Stephanie Hicks\n    url: https://www.stephaniehicks.com\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Introduction to tools to work with functions and vectors in R\"\ndate: 2025-11-04\nknitr: true\ndraft: true\n---\n\n# Motivation \n\nIf you have ever heard the phrase \n\n> \"R is a __functional__ language.\"\n\nyou might have asked yourself what does this means exactly? Generally, this means that R lends itself nice to a particular __style__ of programming, namely a **functional style** of programming (will explain more below), which is often very helpful to the types of problems you encounter when doing a data analysis. \n\n## Functional programming language\n\nA **functional style** of programming is contrast to a the formal definition of a **functional language** (or **functional programming**, which can be complementary to object-oriented programming), which are languages that use functions to create conditional expressions to perform specific computations. \n\n:::{.callout-note}\n\n### Differences between functional and object-oriented programming\n\nFrom [this resource](https://www.indeed.com/career-advice/career-development/functional-programming-languages) some differences are: \n\n- **Basic elements**: The fundamental elements of object-oriented languages are objects and methods, while the elements of functional programming are functions and variables. \n\n- **States**: Object-oriented languages can change objects within the program, which means it has states or current modifications that affect the result of inputs. Functional languages do not use imperative programming, so they do not keep track of current states.\n\n- **Parallel programming**: This type of programming involves multiple computational processes occurring at the same time. Object-oriented languages have little support for parallel programming, but functional languages have extensive support for it.\n\n- **Order**: In object-oriented programming, computations occur in a specific order. In functional programming, computations can occur in any order.\n\n- **Iterative data**: Object-oriented programming uses loops, meaning repeated execution, for iterative data. Functional programming uses recursion for iterative data, meaning it attempts to solve problems using simpler versions of the same problem.\n\n:::\n\nA traditional weakness of functional languages are poorer performance and sometimes unpredictable memory usage, but these have been much reduced in recent years.\n\n\n## Characteristics of a functional language\n\nThere are many definitions for precisely what makes a language functional, but there are two common threads and/or characteristics. \n\n### 1. First-class functions\n\nAt it is core, functional programming treats functions equally as other data structures, called **first class functions**. \n\n> In R, this means that you can do many of the things with a function that you can do with a vector: you can assign them to variables, store them in lists, pass them as arguments to other functions, create them inside functions, and even return them as the result of a function.\n\n\n:::{.callout-tip}\n\n### Examples of cool things you can do with functions in R\n\n1. Assign a function to a variable (`foo`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo <- function(){\n  return(\"This is foo.\")\n}\nclass(foo)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"function\"\n```\n\n\n:::\n\n```{.r .cell-code}\nfoo\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction () \n{\n    return(\"This is foo.\")\n}\n```\n\n\n:::\n\n```{.r .cell-code}\nfoo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"This is foo.\"\n```\n\n\n:::\n:::\n\n\n2. You can store functions in a `list`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo_list <- list( \n  fun_1 = function() return(\"foo_1\"),\n  fun_2 = function() return(\"foo_2\")\n)\n\nstr(foo_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ fun_1:function ()  \n $ fun_2:function ()  \n```\n\n\n:::\n\n```{.r .cell-code}\nfoo_list$fun_1()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"foo_1\"\n```\n\n\n:::\n\n```{.r .cell-code}\nfoo_list$fun_2()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"foo_2\"\n```\n\n\n:::\n:::\n\n\n3. You can pass functions as arguments to other functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshell_fn <- function(f) f()\nshell_fn(foo_list$fun_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"foo_1\"\n```\n\n\n:::\n\n```{.r .cell-code}\nshell_fn(foo_list$fun_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"foo_2\"\n```\n\n\n:::\n:::\n\n\n4. You can **create functions inside of functions** and return them as the result of a function\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo_wrap <- function(){\n  foo_2 <- function(){\n    return(\"This is foo_2.\")\n  }\n  return(foo_2)\n}\n\nfoo_wrap()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction () \n{\n    return(\"This is foo_2.\")\n}\n<environment: 0x138c44698>\n```\n\n\n:::\n\n```{.r .cell-code}\n(foo_wrap())()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"This is foo_2.\"\n```\n\n\n:::\n:::\n\n\nThe bottom line, you can manipulate functions as the same way as you can to a vector or a matrix. \n\n:::\n\n### 2. Pure functions\n\nA function is **pure**, if it satisfies two properties:\n\n* The output only depends on the inputs, i.e. if you call it again with the \n  same inputs, you get the same outputs. This excludes functions like `runif()`,\n  `read.csv()`, or `Sys.time()` that can return different values.\n\n* The function has no side-effects, like changing the value of a global \n  variable, writing to disk, or displaying to the screen. This excludes \n  functions like `print()`, `write.csv()` and `<-`.\n \nPure functions are much easier to reason about, but obviously have significant downsides: imagine doing a data analysis where you could not generate random numbers or read files from disk. \n\n:::{.callout-important}\n\nTo be clear, **R is not formally a functional programming language** as it does not require pure functions to be used when writing code. \n\n:::\n\nSo you might be asking yourself, why are we talking about this then? \n\nThe formal definition of a functional programming language introduces a new style of programming, namely a **functional style** of programming. \n\n:::{.callout-note}\n\nThe key idea of a **functional style** is this programming style encourages programmers to write a big function as many smaller isolated functions, where each function addresses one specific task.\n\n:::\n\nYou can always adopt a **functional style** for certain parts of your code! For example, this style of writing code motivates more humanly readable code, and recyclable code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"data_set.csv\" |> \n  import_data_from_file() |> \n  data_cleaning() |> \n  run_regression() |>\n  model_diagnostics() |>\n  model_visualization()\n\n\"data_set2.csv\" |> \n  import_data_from_file() |> \n  data_cleaning() |> \n  run_different_regression() |>\n  model_diagnostics() |>\n  model_visualization()\n```\n:::\n\n\n\n## Functional style\n\nAt a high-level, a **functional style** is the concept of decomposing a big problem into smaller components, then solving each piece with a function or combination of functions. \n\n- When using a functional style, you strive to decompose components of the problem into isolated functions that operate independently. \n- Each function taken by itself is simple and straightforward to understand; complexity is handled by composing functions in various ways.\n\n### Functionals\n\nIn this lecture, we will focus on one type of functional technique, namely **functionals**, which are functions that take another function as an argument and returns a vector as output.\n\nFunctionals allow you to take a function that solves the problem for a single input and generalize it to handle any number of inputs. Once you learn about them, you will find yourself using them all the time in data analysis.\n\n:::{.callout-note}\n\n### Example of a functional\n\nHere's a simple functional: it calls the function provided as input with 1000 random uniform numbers. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandomise <- function(f) f(runif(1e3))\nrandomise(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5119781\n```\n\n\n:::\n\n```{.r .cell-code}\nrandomise(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5065844\n```\n\n\n:::\n\n```{.r .cell-code}\nrandomise(sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 511.4911\n```\n\n\n:::\n:::\n\n\n:::\n\nThe chances are that you have already used a functional. You might have used for-loop replacements like base R's `lapply()`, `apply()`, and `tapply()` or maybe you have used a mathematical functional like `integrate()` or `optim()`. \n\nOne of the most common use of functionals is an alternative to `for` loops. \n\nFor loops have a bad rap in R because many people believe they are slow, but the real downside of for loops is that they're very flexible: a loop conveys that you're iterating, but not what should be done with the results. \n\n:::{.column-margin}\n\nTypically it is not the for loop itself that is slow, but what you are doing inside of it. A common culprit of slow loops is modifying a data structure, where each modification generates a copy. \n\nIf you're an experienced for loop user, switching to functionals is typically a pattern matching exercise. You look at the for loop and find a functional that matches the basic form. If one does not exist, do not try and torture an existing functional to fit the form you need. Instead, just leave it as a for loop! (Or once you have repeated the same loop two or more times, maybe think about writing your own functional).\n\n:::\n\nJust as it is better to use `while` than `repeat`, and it's better to use `for` than `while`, it is better to use a functional than `for`. \n\nEach functional is tailored for a specific task, so when you recognize the functional you immediately know why it's being used.\n\n\n# `purrr`: the functional programming toolkit\n\nThe R package [`purrr`](https://purrr.tidyverse.org) as one important component of the [`tidyverse`](https://www.tidyverse.org/), provides a interface to manipulate vectors in the _functional style_.\n\n> `purrr` enhances R's functional programming (FP) toolkit by providing a complete and consistent set of tools for working with functions and vectors.\n\n::: callout-tip\n### `purrr` cheatsheet\nIt is very difficult, if not impossible, to remember all functions that a package offers as well as their use cases. \n\nHence, `purrr` developers offer a nice compact cheatsheet with visualizations at <https://github.com/rstudio/cheatsheets/blob/main/purrr.pdf>. \n\nSimilar cheat sheets are available for other `tidyverse` packages.\n:::\n\nThe most popular function in `purrr` is `map()` which iterates over the supplied data structure and apply a function during the iterations. Beside the `map()` function,`purrr` also offers a series of useful functions to manipulate the `list` data frame. \n\n## The `map` family\n\nThe most fundamental functional in the `purrr` package is the `map(.x, .f)` function. It takes a vector (`.x`) and a function (`.f`), calls the function once for each element of the vector, and returns the results in a list. In other words, `map(1:3, f)` is equivalent to `list(f(1), f(2), f(3))`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\n\n# we create a function called \"triple\"\ntriple <- function(x) x * 3\n\n# using for loop to iterate over a vector\nloop_ret <- list()\nfor(i in 1:3){\n  loop_ret[i] <- triple(i)\n}\nloop_ret\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 3\n\n[[2]]\n[1] 6\n\n[[3]]\n[1] 9\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# map implementation to iterate over a vector\nmap_eg1 <- map(.x = 1:3, .f = triple)\nmap_eg2 <- map(.x = 1:3, .f = function(x) triple(x)) # create an inline anonymous function\nmap_eg3 <- map(.x = 1:3, .f = ~triple(.x)) # same as above, but special purrr syntax with a \"twiddle\"\n\n\nidentical(loop_ret,map_eg1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nidentical(loop_ret,map_eg2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nidentical(loop_ret,map_eg3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nOr, graphically this is what `map()` is doing:\n\n![map](../../images/functionals/map.png)\n\n:::{.callout-tip}\n\n### How does `map` relate to functional programming in base R?\n\n`map()` returns a list, which makes it the most general of the map family because you can put anything in a list. \n\nThe base equivalent to `map(.x, .f)` is `lapply(X, FUN)`. \n\nBecause the arguments include functions (`.f`) besides data (`.x`), `map()` functions are considered as a convenient interface to implement functional programming.\n:::\n\n\n### `map` variants\n\nSometimes it is inconvenient to return a list when a simpler data structure would do, so there are four more specific variants of `map` that make it really a **family of functions** (of syntax `map_*()`). \n\n- `map_lgl()`\n- `map_int()`\n- `map_dbl()`\n- `map_chr()`\n\nFor example, `purrr` uses the convention that suffixes, like `_dbl()`, refer to the output. Each returns an atomic vector of the specified type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# map_chr() always returns a character vector\nmap_chr(.x = mtcars, .f = typeof)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     mpg      cyl     disp       hp     drat       wt     qsec       vs \n\"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \n      am     gear     carb \n\"double\" \"double\" \"double\" \n```\n\n\n:::\n\n```{.r .cell-code}\n# map_lgl() always returns a logical vector\nmap_lgl(.x = mtcars, .f = is.double)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \nTRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE \n```\n\n\n:::\n\n```{.r .cell-code}\n# map_int() always returns a integer vector\nn_unique <- function(x) length(unique(x))\nmap_int(.x = mtcars, .f = n_unique)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n  25    3   27   22   22   29   30    2    2    3    6 \n```\n\n\n:::\n\n```{.r .cell-code}\n# map_dbl() always returns a double vector\nmap_dbl(.x = mtcars, .f = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       mpg        cyl       disp         hp       drat         wt       qsec \n 20.090625   6.187500 230.721875 146.687500   3.596563   3.217250  17.848750 \n        vs         am       gear       carb \n  0.437500   0.406250   3.687500   2.812500 \n```\n\n\n:::\n:::\n\n\n:::{.callout-note}\n\n### Pro-tip \n\nAll `map_*()` functions can take any type of vector as input. The examples above rely on two facts: \n\n1. `mtcars` is a `data.frame`. In R, `data.frame` is a special case of `list`, where each column as one item of the list. Don't confuse with each row as an item.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\n2. All `map` functions always return an output vector the same length as the input, which implies that each call to `.f` must return a single value. If it does not, you will get an error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npair <- function(x) c(x, x)\nmap_dbl(.x = 1:2, .f = pair)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `map_dbl()`:\nℹ In index: 1.\nCaused by error:\n! Result must be length 1, not 2.\n```\n\n\n:::\n:::\n\n\nThis is similar to the error you will get if `.f` returns the wrong type of result:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(1:2, as.character)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `map_dbl()`:\nℹ In index: 1.\nCaused by error:\n! Can't coerce from a string to a double.\n```\n\n\n:::\n:::\n\n\n:::\n\n\n:::{.callout-note}\n\n### Question\n\nLet's assume I have a dataframe called `tmp_dat`. How would I use `map()` to calculate the mean for the columns? \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmp_dat <- data.frame(\n  x = 1:5,\n  y = 6:10\n)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## try it out \n```\n:::\n\n:::\n\n:::{.callout-note}\n\n### Question \n\nCan we re-write the `map()` function above to use `tmp_data` as input with the `|>` operator? \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## try it out \n```\n:::\n\n\n:::\n\n\n### Passing arguments with `...` \n\nIt is often convenient to pass along additional arguments to the function that you are calling.\n\nFor example, you might want to pass `na.rm = TRUE` along to `mean()`. One way to do that is with an anonymous function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(1:5, c(1:10, NA))\nmap_dbl(x, ~ mean(.x, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.0 5.5\n```\n\n\n:::\n:::\n\n\nBut because the map functions pass `...` along, there is a simpler form available:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(x, mean, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.0 5.5\n```\n\n\n:::\n:::\n\n\nThis is easiest to understand with a picture: any arguments that come after `f` in the call to `map()` are inserted _after_ the data in individual calls to `f()`:\n\n![map](../../images/functionals/map-arg.png)\n\n:::{.callout-note}\n\nIt's important to note that these arguments are not decomposed; or said another way, `map()` is only vectorised over its first argument. \n\nIf an argument after `f` is a vector, it will be passed along as is:\n\n![map](../../images/functionals/map-arg-recycle.png)\n\n:::\n\n### Stratified analysis with `map`\n\nBefore we go on to explore more map variants, let's take a quick look at how you tend to use multiple `purrr` functions to solve a moderately realistic problem: fitting a model to each subgroup and extracting a coefficient of the model. \n\nFor this toy example, I will break the `mtcars` data set down into groups defined by the number of cylinders, using the base `split` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# different numbers of cylinders\nunique(mtcars$cyl) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6 4 8\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nby_cyl <- split(mtcars, mtcars$cyl)\nlength(by_cyl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(by_cyl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 3\n $ 4:'data.frame':\t11 obs. of  11 variables:\n  ..$ mpg : num [1:11] 22.8 24.4 22.8 32.4 30.4 33.9 21.5 27.3 26 30.4 ...\n  ..$ cyl : num [1:11] 4 4 4 4 4 4 4 4 4 4 ...\n  ..$ disp: num [1:11] 108 146.7 140.8 78.7 75.7 ...\n  ..$ hp  : num [1:11] 93 62 95 66 52 65 97 66 91 113 ...\n  ..$ drat: num [1:11] 3.85 3.69 3.92 4.08 4.93 4.22 3.7 4.08 4.43 3.77 ...\n  ..$ wt  : num [1:11] 2.32 3.19 3.15 2.2 1.61 ...\n  ..$ qsec: num [1:11] 18.6 20 22.9 19.5 18.5 ...\n  ..$ vs  : num [1:11] 1 1 1 1 1 1 1 1 0 1 ...\n  ..$ am  : num [1:11] 1 0 0 1 1 1 0 1 1 1 ...\n  ..$ gear: num [1:11] 4 4 4 4 4 4 3 4 5 5 ...\n  ..$ carb: num [1:11] 1 2 2 1 2 1 1 1 2 2 ...\n $ 6:'data.frame':\t7 obs. of  11 variables:\n  ..$ mpg : num [1:7] 21 21 21.4 18.1 19.2 17.8 19.7\n  ..$ cyl : num [1:7] 6 6 6 6 6 6 6\n  ..$ disp: num [1:7] 160 160 258 225 168 ...\n  ..$ hp  : num [1:7] 110 110 110 105 123 123 175\n  ..$ drat: num [1:7] 3.9 3.9 3.08 2.76 3.92 3.92 3.62\n  ..$ wt  : num [1:7] 2.62 2.88 3.21 3.46 3.44 ...\n  ..$ qsec: num [1:7] 16.5 17 19.4 20.2 18.3 ...\n  ..$ vs  : num [1:7] 0 0 1 1 1 1 0\n  ..$ am  : num [1:7] 1 1 0 0 0 0 1\n  ..$ gear: num [1:7] 4 4 3 3 4 4 5\n  ..$ carb: num [1:7] 4 4 1 1 4 4 6\n $ 8:'data.frame':\t14 obs. of  11 variables:\n  ..$ mpg : num [1:14] 18.7 14.3 16.4 17.3 15.2 10.4 10.4 14.7 15.5 15.2 ...\n  ..$ cyl : num [1:14] 8 8 8 8 8 8 8 8 8 8 ...\n  ..$ disp: num [1:14] 360 360 276 276 276 ...\n  ..$ hp  : num [1:14] 175 245 180 180 180 205 215 230 150 150 ...\n  ..$ drat: num [1:14] 3.15 3.21 3.07 3.07 3.07 2.93 3 3.23 2.76 3.15 ...\n  ..$ wt  : num [1:14] 3.44 3.57 4.07 3.73 3.78 ...\n  ..$ qsec: num [1:14] 17 15.8 17.4 17.6 18 ...\n  ..$ vs  : num [1:14] 0 0 0 0 0 0 0 0 0 0 ...\n  ..$ am  : num [1:14] 0 0 0 0 0 0 0 0 0 0 ...\n  ..$ gear: num [1:14] 3 3 3 3 3 3 3 3 3 3 ...\n  ..$ carb: num [1:14] 2 4 3 3 3 4 4 4 2 2 ...\n```\n\n\n:::\n:::\n\n\nThis creates a list of three data frames: the cars with 4, 6, and 8 cylinders respectively.\n\nFirst, imagine we want to fit a linear model to understand how the miles per gallon (`mpg`) associated with the weight (`wt`). We can do this for all observations in `mtcars` using: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm(mpg ~ wt, data = mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = mpg ~ wt, data = mtcars)\n\nCoefficients:\n(Intercept)           wt  \n     37.285       -5.344  \n```\n\n\n:::\n:::\n\n\nThe following code shows how you might do that with `purrr`, which returns a list with output from each lm fit for each cylinder:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nby_cyl |>\n  map(.f = ~ lm(mpg ~ wt, data = .x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`4`\n\nCall:\nlm(formula = mpg ~ wt, data = .x)\n\nCoefficients:\n(Intercept)           wt  \n     39.571       -5.647  \n\n\n$`6`\n\nCall:\nlm(formula = mpg ~ wt, data = .x)\n\nCoefficients:\n(Intercept)           wt  \n      28.41        -2.78  \n\n\n$`8`\n\nCall:\nlm(formula = mpg ~ wt, data = .x)\n\nCoefficients:\n(Intercept)           wt  \n     23.868       -2.192  \n```\n\n\n:::\n:::\n\n\n:::{.callout-note}\n\n### Question \n\nLet's say we wanted to extract the second coefficient (i.e. the slope). Using all the observations in `mtcars` (i.e. ignoring `cyl`), it would be something like this: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm.fit <- lm(mpg ~ wt, data = mtcars)\ncoef(lm.fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept)          wt \n  37.285126   -5.344472 \n```\n\n\n:::\n\n```{.r .cell-code}\ncoef(lm.fit)[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       wt \n-5.344472 \n```\n\n\n:::\n:::\n\n\nHow would we do this with the `map()` family functions if we wanted to stratify the analysis for each `cyl`? \n\n**Hint**: you can use two `map` functions (e.g. `map()` and `map_dbl(2)` where you can extract a specific element by a specific name or position). \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## try it out \n```\n:::\n\n\n:::\n\n\nOr, of course, you could use a for loop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslopes <- double(length(by_cyl))\nfor (i in seq_along(by_cyl)) {\n  model <- lm(mpg ~ wt, data = by_cyl[[i]])\n  slopes[[i]] <- coef(model)[[2]]\n}\nslopes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -5.647025 -2.780106 -2.192438\n```\n\n\n:::\n:::\n\n\nIt's interesting to note that as you move from purrr to base apply functions to for loops you tend to do more and more in each iteration. \n\nIn purrr we iterate 3 times (`map()`, `map()`, `map_dbl()`), and with a for loop we iterate once. I prefer more, but simpler, steps because I think it makes the code easier to understand and later modify.\n\n:::{.callout-note}\n\n### Question\n\nNow we are interested in calculating the average `mpg` for vehicles with different numbers of cylinders. How can we use `map` functions to do this? You can return a list. \n\n**Hint**: You can use the syntax `x$mpg` where `x` is a dataframe within a `map` function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## try it out \n```\n:::\n\n\n:::\n\n\n### Matrix as the output\n\nThe `map` family include functions that organize the output in different data structures, whose names follow the pattern `map_*`. As we've seen, the `map` function return a list. The following functions will return a vector of a specific kind, e.g. `map_lgl` returns a vector of logical variables, `map_chr` returns a vector of strings. \n\nIt is also possible to return the the results as data frames by \n\n- row binding (`map_dfr`) or \n- column binding (`map_dfc`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nby_cyl |> \n  map_dbl(.f = ~mean(.x$mpg)) # returns a vector of doubles\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       4        6        8 \n26.66364 19.74286 15.10000 \n```\n\n\n:::\n\n```{.r .cell-code}\nby_cyl |> \n  map_dfr(.f = ~colMeans(.x)) # return a data frame by row binding\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 11\n    mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1  26.7     4  105.  82.6  4.07  2.29  19.1 0.909 0.727  4.09  1.55\n2  19.7     6  183. 122.   3.59  3.12  18.0 0.571 0.429  3.86  3.43\n3  15.1     8  353. 209.   3.23  4.00  16.8 0     0.143  3.29  3.5 \n```\n\n\n:::\n\n```{.r .cell-code}\nby_cyl |> \n  map_dfc(.f = ~colMeans(.x)) # return a data frame by col binding\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 11 × 3\n       `4`     `6`     `8`\n     <dbl>   <dbl>   <dbl>\n 1  26.7    19.7    15.1  \n 2   4       6       8    \n 3 105.    183.    353.   \n 4  82.6   122.    209.   \n 5   4.07    3.59    3.23 \n 6   2.29    3.12    4.00 \n 7  19.1    18.0    16.8  \n 8   0.909   0.571   0    \n 9   0.727   0.429   0.143\n10   4.09    3.86    3.29 \n11   1.55    3.43    3.5  \n```\n\n\n:::\n:::\n\n\n## More map variants\n\nThere are 23 primary variants of `map()`. So far, we have learned about five (`map()`, `map_lgl()`, `map_int()`, `map_dbl()` and `map_chr()`). That means that you have got 18 (!!) more to learn. That sounds like a lot, but fortunately the design of `purrr` means that you only need to learn five new ideas:\n\n* Output same type as input with `modify()`\n* Iterate over two inputs with `map2()`.\n* Iterate with an index using `imap()`\n* Return nothing with `walk()`.\n* Iterate over any number of inputs with `pmap()`.\n\nThe map family of functions has orthogonal input and outputs, meaning that we can organise all the family into a matrix, with inputs in the rows and outputs in the columns. Once you have mastered the idea in a row, you can combine it with any column; once you have mastered the idea in a column, you can combine it with any row. That relationship is summarised in the following table:\n\n|                       | List     | Atomic            | Same type   | Nothing   |\n|-----------------------|----------|-------------------|-------------|-----------|\n| One argument          | `map()`  | `map_lgl()`, ...  | `modify()`  | `walk()`  |\n| Two arguments         | `map2()` | `map2_lgl()`, ... | `modify2()` | `walk2()` |\n| One argument + index  | `imap()` | `imap_lgl()`, ... | `imodify()` | `iwalk()` |\n| N arguments           | `pmap()` | `pmap_lgl()`, ... | ---         | `pwalk()` |\n\n\n### `modify()` \n\nImagine you wanted to double every column in a data frame. You might first try using `map()`, but `map()` always returns a list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n  x = 1:3,\n  y = 6:4\n)\n\nmap(df, ~ .x * 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$x\n[1] 2 4 6\n\n$y\n[1] 12 10  8\n```\n\n\n:::\n:::\n\n\nIf you want to keep the output as a data frame, you can use `modify()`, which always returns the same type of output as the input:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodify(df, ~ .x * 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x  y\n1 2 12\n2 4 10\n3 6  8\n```\n\n\n:::\n:::\n\n\n:::{.callout-note}\n\nDespite the name, `modify()` doesn't modify in place, it returns a modified copy, so if you wanted to permanently modify `df`, you'd need to assign it: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- modify(df, ~ .x * 2)\n```\n:::\n\n:::\n\n\n### `map2()` and friends {#map2}\n\\indexc{map2()}\n\n`map()` is vectorised over a single argument, `.x`. \n\nThis means it only varies `.x` when calling `.f`, and all other arguments are passed along unchanged, thus making it poorly suited for some problems. \n\nFor example, how would you find a weighted mean when you have a list of observations and a list of weights? Imagine we have the following data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxs <- map(1:8, ~ runif(10))\nxs[[1]][[1]] <- NA\nws <- map(1:8, ~ rpois(10, 5) + 1)\n```\n:::\n\n\nYou can use `map_dbl()` to compute the unweighted means:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(.x = xs, .f = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]        NA 0.6668531 0.5870993 0.4352537 0.4624854 0.4763340 0.5079496\n[8] 0.5167367\n```\n\n\n:::\n:::\n\n\nBut passing `ws` as an additional argument does not work because arguments after `.f` are not transformed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(x. = xs, .f = weighted.mean, w = ws)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in map_dbl(x. = xs, .f = weighted.mean, w = ws): argument \".x\" is missing, with no default\n```\n\n\n:::\n:::\n\n\nWe need a new tool: a `map2()`, which is vectorised over two arguments. This means both `.x` and `.y` are varied in each call to `.f`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap2_dbl(.x = xs, .y = ws, .f = weighted.mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]        NA 0.6707411 0.5577987 0.4414804 0.4820341 0.5147982 0.5985934\n[8] 0.5092437\n```\n\n\n:::\n:::\n\n\nThe arguments to `map2()` are slightly different to the arguments to `map()` as two vectors come before the function, rather than one. Additional arguments still go afterwards:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap2_dbl(.x = xs, .y = ws, .f = weighted.mean, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.4794579 0.6707411 0.5577987 0.4414804 0.4820341 0.5147982 0.5985934\n[8] 0.5092437\n```\n\n\n:::\n:::\n\n\n\n\n### `walk()` and friends\n\nMost functions are called for the value that they return, so it makes sense to capture and store the value with a `map()` function. \n\nBut some functions are called primarily for their side-effects (e.g. `cat()`, `write.csv()`, or `ggsave()`) and it does not make sense to capture their results.\n\nLet's consider the example of saving a dataset. In this case, `map` will force an output, e.g. `NULL`. One can consider using `walk` instead. The function `walk` (and `walk2` for more than two inputs) behaves exactly the same as `map` but does not output anything. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmp_fldr <- tempdir()\n\nmap2(.x = by_cyl,\n     .y = 1:length(by_cyl),\n     .f = ~saveRDS(.x, \n                   file = paste0(tmp_fldr, \"/\",.y, \".rds\"))\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`4`\nNULL\n\n$`6`\nNULL\n\n$`8`\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\n# No output\nwalk2(.x = by_cyl,\n      .y = (1:length(by_cyl)),\n      .f = ~saveRDS(.x, \n                    file = paste0(tmp_fldr, \"/\",.y, \".rds\"))\n)\n```\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}